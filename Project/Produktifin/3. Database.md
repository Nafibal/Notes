# Design principles / assumptions

- Each microservice **owns** its schema (recommended): `auth`, `pomodoro`, `history`, `calendar` (separate DBs or schemas). This avoids coupling and enables independent deployment.
    
- Use `uuid` primary keys (Postgres `uuid_generate_v4()`), `timestamps` with `timezone`.
    
- Store user-sensitive data only in `auth` DB (`users`, `password_hash`).
    
- For quick lookups and active state (running sessions, guest ephemeral), use **Redis** (not modelled here).
    
- Soft-deletes use `deleted_at` (nullable timestamp).
    
- Add common audit fields: `created_at`, `updated_at`, `deleted_at`.
    

---

## 1) Auth Service — schema `auth`

Responsible for user accounts, tokens, and user settings reference.

```sql
-- enable uuid extension (run once per database)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- users table (auth-service)
CREATE TABLE auth.users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT NOT NULL UNIQUE,
    name TEXT,
    password_hash TEXT NOT NULL, -- bcrypt/argon2 hashed
    is_active BOOL NOT NULL DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- refresh tokens (rotate/store if you want server-side revocation)
CREATE TABLE auth.refresh_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL, -- store hash of refresh token only
    issued_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,
    revoked_at TIMESTAMPTZ,
    last_used_at TIMESTAMPTZ
);

CREATE INDEX idx_refresh_tokens_user ON auth.refresh_tokens(user_id);

-- user settings can live here or in user_settings service; placed here for direct lookup
CREATE TABLE auth.user_settings (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    default_pomodoro_minutes INT NOT NULL DEFAULT 25,
    default_short_break_minutes INT NOT NULL DEFAULT 5,
    default_long_break_minutes INT NOT NULL DEFAULT 15,
    long_break_interval INT NOT NULL DEFAULT 4,
    theme TEXT NOT NULL DEFAULT 'light',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

Notes:

- Keep password reset tokens in a short-lived table (or external store).
    
- `refresh_tokens` allow revocation. If you want stateless only, omit refresh token storage.
    

---

## 2) Pomodoro Service — schema `pomodoro`

Responsible for active sessions and tasks. Running/paused sessions stored here (for authenticated users). Guest sessions should be in Redis or localStorage; if you must persist short-term in DB, use TTL cleanup.

```sql
CREATE SCHEMA IF NOT EXISTS pomodoro;

-- Active/archived sessions
CREATE TABLE pomodoro.sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NULL, -- nullable for guest (if saved server-side)
    status TEXT NOT NULL CHECK (status IN ('running','paused','finished','planned')),
    duration_pomodoro_minutes INT NOT NULL DEFAULT 25,
    duration_short_break_minutes INT NOT NULL DEFAULT 5,
    duration_long_break_minutes INT NOT NULL DEFAULT 15,
    long_break_interval INT NOT NULL DEFAULT 4,
    pomodoro_count INT NOT NULL DEFAULT 0,
    short_break_count INT NOT NULL DEFAULT 0,
    long_break_count INT NOT NULL DEFAULT 0,
    total_focused_seconds INT NOT NULL DEFAULT 0,
    progress_seconds INT NOT NULL DEFAULT 0, -- seconds elapsed in current interval
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

CREATE INDEX idx_sessions_user_status ON pomodoro.sessions(user_id, status);
CREATE INDEX idx_sessions_start_time ON pomodoro.sessions(start_time);

-- Tasks attached to sessions
CREATE TABLE pomodoro.tasks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    session_id UUID NOT NULL REFERENCES pomodoro.sessions(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    is_done BOOL NOT NULL DEFAULT false,
    position INT NOT NULL DEFAULT 0, -- ordering
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_tasks_session ON pomodoro.tasks(session_id);
```

Notes:

- Client-controlled timer with periodic sync to `progress_seconds` to minimize writes. But auto-save on status change is required.
    
- If you plan to support multi-device real-time resume, use WebSockets + persistence of `progress_seconds` frequently.
    

---

## 3) History Service — schema `history`

Stores completed/archived session snapshots. This is the main audit/log store for analytics and reports. The `pomodoro` service can push finished-session snapshots into `history` (eventual consistency).

```sql
CREATE SCHEMA IF NOT EXISTS history;

-- Archived session snapshots
CREATE TABLE history.sessions_archive (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    original_session_id UUID, -- optional, links to pomodoro.sessions if same DB
    user_id UUID NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('finished','paused','planned')),
    pomodoro_count INT NOT NULL DEFAULT 0,
    short_break_count INT NOT NULL DEFAULT 0,
    long_break_count INT NOT NULL DEFAULT 0,
    duration_pomodoro_minutes INT NOT NULL DEFAULT 25,
    duration_short_break_minutes INT NOT NULL DEFAULT 5,
    duration_long_break_minutes INT NOT NULL DEFAULT 15,
    total_focused_seconds INT NOT NULL DEFAULT 0,
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()  -- when archived
);

CREATE INDEX idx_history_user_date ON history.sessions_archive(user_id, created_at DESC);

-- Store tasks snapshot as JSON or normalized table; choose JSON for easier archival
CREATE TABLE history.session_tasks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    archived_session_id UUID NOT NULL REFERENCES history.sessions_archive(id) ON DELETE CASCADE,
    tasks JSONB NOT NULL, -- array of task objects as snapshot
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Optionally: materialized analytics table (daily aggregates)
CREATE TABLE history.daily_user_aggregates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    date_date DATE NOT NULL,
    total_pomodoros INT NOT NULL DEFAULT 0,
    total_focused_seconds INT NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(user_id, date_date)
);

CREATE INDEX idx_aggregates_user_date ON history.daily_user_aggregates(user_id, date_date DESC);
```

Notes:

- Use `JSONB` for archived tasks to keep snapshot integrity.
    
- Consider partitioning `sessions_archive` by year for large scale.
    

---

## 4) Calendar Service — schema `calendar`

Stores planned events (Pomodoro sessions scheduled in future). Calendar events can spawn pomodoro sessions.

```sql
CREATE SCHEMA IF NOT EXISTS calendar;

CREATE TABLE calendar.events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    scheduled_start TIMESTAMPTZ NOT NULL,
    duration_minutes INT NOT NULL DEFAULT 25,
    repeat_type TEXT NOT NULL DEFAULT 'none', -- none,daily,weekly,monthly
    repeat_until TIMESTAMPTZ,
    status TEXT NOT NULL CHECK (status IN ('planned','cancelled','completed')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_events_user_date ON calendar.events(user_id, scheduled_start);
CREATE INDEX idx_events_status ON calendar.events(status);
```

Notes:

- For recurring events you can either expand occurrences into another table `calendar.event_instances` or compute occurrences on-the-fly.
    
- When a user clicks "start" on an event, the calendar service calls Pomodoro service to create a new session and should update `status`/link the `session_id`.
    

---

## 5) Notification Service (optional) — schema `notification`

If you add reminders or push notifications, store scheduling metadata:

```sql
CREATE SCHEMA IF NOT EXISTS notification;

CREATE TABLE notification.reminders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    event_id UUID NULL, -- optional link to calendar.events
    type TEXT NOT NULL CHECK (type IN ('email','webpush','sms')),
    scheduled_for TIMESTAMPTZ NOT NULL,
    payload JSONB,
    sent_at TIMESTAMPTZ,
    status TEXT NOT NULL CHECK (status IN ('pending','sent','failed','cancelled')) DEFAULT 'pending',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_reminders_user_scheduled ON notification.reminders(user_id, scheduled_for);
```

---

## 6) Cross-service references & foreign keys

- Ideally, only `auth.users.id` is referenced by other services but as plain `UUID` **without DB-level FK** if databases are separate (to avoid cross-DB FK). Use application-level referential integrity.
    
- If services share a DB/schema, use FK constraints (as shown in some examples).
    

---

## 7) Indexing, partitioning, and scaling notes

- Index columns used in filters: `user_id`, `status`, `scheduled_start`, `created_at`.
    
- For heavy `history.sessions_archive`, **partition by range on `created_at`** or by year.
    
- Use connection pooling (PgBouncer) and read replicas for history/analytics reads.
    
- Use Redis for ephemeral guest sessions and for active session state (to reduce DB write churn).
    

---

## 8) Retention / cleanup policies

- Guest ephemeral sessions: TTL in Redis (e.g., 24–72 hours).
    
- Paused sessions older than X days: schedule a cleanup job to delete or archive (configurable, e.g., 30 days).
    
- History archival: move older history (>1 year) to cold storage / separate partition.
    

---

## 9) ER summary (compact)

- `auth.users (id)` ← referenced by `auth.user_settings(user_id)`, `refresh_tokens(user_id)`.
    
- `pomodoro.sessions (id)` ← has many `pomodoro.tasks(session_id)`.
    
- `history.sessions_archive (id)` ← stores archived session data for `user_id` and optional `original_session_id`.
    
- `history.session_tasks (archived_session_id)` ← JSONB snapshot of tasks.
    
- `calendar.events (id)` ← `user_id` and can spawn `pomodoro.sessions` (via `original_event_id` or linking field if needed).
    
- `notification.reminders (event_id)` ← optional link to `calendar.events`.
    

---

## 10) Example: create session + archive flow (short)

1. User creates session → stored in `pomodoro.sessions`.
    
2. When finished: Pomodoro service persists final state to `history.sessions_archive` (and JSON snapshot in `history.session_tasks`), increments `daily_user_aggregates`.
    
3. Pomodoro service deletes or marks `pomodoro.sessions` as finished (depending on whether you want active sessions stored).
    

---

If you want, I can now:

- Generate **SQL migration files** for a specific service (e.g., `pomodoro` only), or
    
- Produce a **single combined ERD** in text (Mermaid) so you can paste it into a renderer, or
    
- Produce a **docker-compose + init SQL** snippet that boots Postgres and applies these schemas.
    

Which would you like next?